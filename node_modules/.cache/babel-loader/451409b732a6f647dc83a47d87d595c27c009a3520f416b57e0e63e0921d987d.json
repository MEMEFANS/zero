{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useState, useCallback } from 'react';\nimport { useWeb3React } from '@web3-react/core';\nimport { ethers } from 'ethers';\nimport { MYSTERY_BOX_ADDRESS, MYSTERY_BOX_ABI, ZONE_TOKEN_ADDRESS, ZONE_TOKEN_ABI, STAKING_ADDRESS, STAKING_ABI } from '../constants/contracts';\nexport const useNFTContract = () => {\n  _s();\n  const {\n    active,\n    library,\n    account\n  } = useWeb3React();\n  const [contracts, setContracts] = useState({\n    nft: null,\n    token: null,\n    staking: null\n  });\n  useEffect(() => {\n    if (active && library) {\n      const nftContract = new ethers.Contract(MYSTERY_BOX_ADDRESS, MYSTERY_BOX_ABI, library.getSigner());\n      const tokenContract = new ethers.Contract(ZONE_TOKEN_ADDRESS, ZONE_TOKEN_ABI, library.getSigner());\n      const stakingContract = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, library.getSigner());\n      setContracts({\n        nft: nftContract,\n        token: tokenContract,\n        staking: stakingContract\n      });\n    }\n  }, [active, library]);\n  const getOwnedNFTs = useCallback(async () => {\n    if (!contracts.nft || !account) return [];\n    try {\n      const tokenIds = await contracts.nft.getOwnedNFTs(account);\n      const nfts = await Promise.all(tokenIds.map(async id => {\n        const attributes = await contracts.nft.getNFTAttributes(id);\n        return {\n          tokenId: id.toNumber(),\n          attributes: {\n            rarity: attributes.rarity,\n            power: attributes.power.toNumber(),\n            dailyReward: attributes.dailyReward.toNumber(),\n            maxReward: attributes.maxReward.toNumber(),\n            minedAmount: attributes.minedAmount.toNumber(),\n            isStaked: attributes.isStaked,\n            stakeTime: attributes.stakeTime.toNumber()\n          }\n        };\n      }));\n      return nfts;\n    } catch (error) {\n      console.error('Failed to get owned NFTs:', error);\n      return [];\n    }\n  }, [contracts.nft, account]);\n  const listNFT = useCallback(async (tokenId, price) => {\n    if (!contracts.nft) return;\n    try {\n      const tx = await contracts.nft.listNFT(tokenId, ethers.utils.parseEther(price.toString()));\n      await tx.wait();\n      return true;\n    } catch (error) {\n      console.error('Failed to list NFT:', error);\n      return false;\n    }\n  }, [contracts.nft]);\n  const buyNFT = useCallback(async (tokenId, price) => {\n    if (!contracts.nft) return;\n    try {\n      const tx = await contracts.nft.buyNFT(tokenId, {\n        value: ethers.utils.parseEther(price.toString())\n      });\n      await tx.wait();\n      return true;\n    } catch (error) {\n      console.error('Failed to buy NFT:', error);\n      return false;\n    }\n  }, [contracts.nft]);\n  return {\n    contracts,\n    getOwnedNFTs,\n    listNFT,\n    buyNFT\n  };\n};\n_s(useNFTContract, \"rWxe8ReoXGEOXRZLnmfIhwF+YCw=\", false, function () {\n  return [useWeb3React];\n});\nexport default useNFTContract;","map":{"version":3,"names":["useEffect","useState","useCallback","useWeb3React","ethers","MYSTERY_BOX_ADDRESS","MYSTERY_BOX_ABI","ZONE_TOKEN_ADDRESS","ZONE_TOKEN_ABI","STAKING_ADDRESS","STAKING_ABI","useNFTContract","_s","active","library","account","contracts","setContracts","nft","token","staking","nftContract","Contract","getSigner","tokenContract","stakingContract","getOwnedNFTs","tokenIds","nfts","Promise","all","map","id","attributes","getNFTAttributes","tokenId","toNumber","rarity","power","dailyReward","maxReward","minedAmount","isStaked","stakeTime","error","console","listNFT","price","tx","utils","parseEther","toString","wait","buyNFT","value"],"sources":["c:/Users/Administrator/CascadeProjects/AIMiner/src/hooks/useNFTContract.js"],"sourcesContent":["import { useEffect, useState, useCallback } from 'react';\nimport { useWeb3React } from '@web3-react/core';\nimport { ethers } from 'ethers';\nimport { \n  MYSTERY_BOX_ADDRESS, \n  MYSTERY_BOX_ABI,\n  ZONE_TOKEN_ADDRESS,\n  ZONE_TOKEN_ABI,\n  STAKING_ADDRESS,\n  STAKING_ABI\n} from '../constants/contracts';\n\nexport const useNFTContract = () => {\n  const { active, library, account } = useWeb3React();\n  const [contracts, setContracts] = useState({\n    nft: null,\n    token: null,\n    staking: null\n  });\n\n  useEffect(() => {\n    if (active && library) {\n      const nftContract = new ethers.Contract(\n        MYSTERY_BOX_ADDRESS,\n        MYSTERY_BOX_ABI,\n        library.getSigner()\n      );\n\n      const tokenContract = new ethers.Contract(\n        ZONE_TOKEN_ADDRESS,\n        ZONE_TOKEN_ABI,\n        library.getSigner()\n      );\n\n      const stakingContract = new ethers.Contract(\n        STAKING_ADDRESS,\n        STAKING_ABI,\n        library.getSigner()\n      );\n\n      setContracts({\n        nft: nftContract,\n        token: tokenContract,\n        staking: stakingContract\n      });\n    }\n  }, [active, library]);\n\n  const getOwnedNFTs = useCallback(async () => {\n    if (!contracts.nft || !account) return [];\n    try {\n      const tokenIds = await contracts.nft.getOwnedNFTs(account);\n      const nfts = await Promise.all(\n        tokenIds.map(async (id) => {\n          const attributes = await contracts.nft.getNFTAttributes(id);\n          return {\n            tokenId: id.toNumber(),\n            attributes: {\n              rarity: attributes.rarity,\n              power: attributes.power.toNumber(),\n              dailyReward: attributes.dailyReward.toNumber(),\n              maxReward: attributes.maxReward.toNumber(),\n              minedAmount: attributes.minedAmount.toNumber(),\n              isStaked: attributes.isStaked,\n              stakeTime: attributes.stakeTime.toNumber()\n            }\n          };\n        })\n      );\n      return nfts;\n    } catch (error) {\n      console.error('Failed to get owned NFTs:', error);\n      return [];\n    }\n  }, [contracts.nft, account]);\n\n  const listNFT = useCallback(async (tokenId, price) => {\n    if (!contracts.nft) return;\n    try {\n      const tx = await contracts.nft.listNFT(tokenId, ethers.utils.parseEther(price.toString()));\n      await tx.wait();\n      return true;\n    } catch (error) {\n      console.error('Failed to list NFT:', error);\n      return false;\n    }\n  }, [contracts.nft]);\n\n  const buyNFT = useCallback(async (tokenId, price) => {\n    if (!contracts.nft) return;\n    try {\n      const tx = await contracts.nft.buyNFT(tokenId, {\n        value: ethers.utils.parseEther(price.toString())\n      });\n      await tx.wait();\n      return true;\n    } catch (error) {\n      console.error('Failed to buy NFT:', error);\n      return false;\n    }\n  }, [contracts.nft]);\n\n  return {\n    contracts,\n    getOwnedNFTs,\n    listNFT,\n    buyNFT\n  };\n};\n\nexport default useNFTContract;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}